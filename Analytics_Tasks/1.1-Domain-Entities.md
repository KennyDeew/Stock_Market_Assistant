# Task 1.1: Implement Domain Entities

**Section:** Domain Layer  
**Priority:** High  
**Estimated Time:** 2-3 hours  
**Dependencies:** None

## Objective

Implement core domain entities (AssetTransaction, AssetRating) that represent business concepts in the Analytics domain.

## Context

Domain entities encapsulate business rules and invariants. They should be:
- Framework-agnostic (no EF Core attributes)
- Rich in behavior (not anemic)
- Self-validating

## Requirements

### AssetTransaction Entity

Represents a single portfolio transaction received from Kafka.

**Properties:**
```csharp
public class AssetTransaction
{
    public Guid Id { get; private set; }
    public Guid PortfolioId { get; private set; }
    public Guid StockCardId { get; private set; }
    public TransactionType TransactionType { get; private set; }
    public decimal Quantity { get; private set; }
    public decimal Price { get; private set; }
    public decimal TotalAmount { get; private set; }
    public DateTime TransactionDate { get; private set; }
    public DateTime CreatedAt { get; private set; }
}
```

**Business Rules:**
- `Quantity` must be > 0
- `Price` must be >= 0
- `TotalAmount` must equal `Quantity * Price`
- `TransactionDate` cannot be in the future
- `Id` is generated on creation (new Guid())
- `CreatedAt` is set to UTC now on creation

**Factory Method:**
```csharp
public static AssetTransaction Create(
    Guid portfolioId,
    Guid stockCardId,
    TransactionType transactionType,
    decimal quantity,
    decimal price,
    DateTime transactionDate)
{
    // Validate business rules
    // Calculate TotalAmount
    // Return new instance
}
```

### AssetRating Entity

Represents aggregated analytics for an asset over a period.

**Properties:**
```csharp
public class AssetRating
{
    public Guid Id { get; private set; }
    public Guid StockCardId { get; private set; }
    public DateTime PeriodStart { get; private set; }
    public DateTime PeriodEnd { get; private set; }
    public AnalysisContext Context { get; private set; }
    public Guid? PortfolioId { get; private set; }
    
    public int BuyTransactionCount { get; private set; }
    public int SellTransactionCount { get; private set; }
    public decimal TotalBuyAmount { get; private set; }
    public decimal TotalSellAmount { get; private set; }
    
    public int TransactionCountRank { get; private set; }
    public int TransactionAmountRank { get; private set; }
    
    public DateTime UpdatedAt { get; private set; }
}
```

**Business Rules:**
- `PeriodStart` < `PeriodEnd`
- If `Context` == `Portfolio`, `PortfolioId` must be set
- If `Context` == `Global`, `PortfolioId` must be null
- All count and amount values must be >= 0
- Ranks must be > 0

**Methods:**
```csharp
public void UpdateCounts(int buyCount, int sellCount, decimal buyAmount, decimal sellAmount)
public void AssignRanks(int countRank, int amountRank)
public void MarkAsUpdated()
```

## Acceptance Criteria

- [x] `AssetTransaction` entity class exists in `Domain/Entities/`
- [x] `AssetRating` entity class exists in `Domain/Entities/`
- [x] All properties have private setters
- [x] Factory methods validate business rules and throw `ArgumentException` on violation
- [x] `TotalAmount` is auto-calculated in `AssetTransaction.Create()`
- [x] `CreatedAt` and `UpdatedAt` are set automatically
- [x] No EF Core attributes (purely domain logic)

## File Structure

```
Domain/
  Entities/
    AssetTransaction.cs
    AssetRating.cs
```

## Testing

Create unit tests in Section 7 (Task 7.1) that verify:
- Valid entity creation
- Business rule validation
- Factory method behavior
- Edge cases (zero values, future dates, etc.)

## References

- Technical Specification: Section "Модель данных"
- Clean Architecture: Entities should not depend on frameworks