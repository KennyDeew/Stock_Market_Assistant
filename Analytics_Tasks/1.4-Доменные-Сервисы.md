# Задание 1.4: Реализация доменных сервисов

**Раздел:** Domain Layer  
**Приоритет:** Высокий  
**Время:** 3-4 часа  
**Зависимости:** 1.1, 1.2, 1.3

## Цель

Реализовать RatingCalculationService с основной бизнес-логикой расчёта рейтингов.

## Требования

### RatingCalculationService

Местоположение: `Domain/Services/RatingCalculationService.cs`

**Методы:**

#### 1. CreateRating

Создаёт AssetRating из группы транзакций.

```csharp
public AssetRating CreateRating(
    IGrouping<Guid, AssetTransaction> transactionGroup,
    Period period,
    AnalysisContext context,
    Guid? portfolioId)
```

**Логика:**
- Разделить транзакции на покупки и продажи
- Вычислить количество и суммы
- Создать и вернуть AssetRating

#### 2. AssignRanks

Присваивает ранги коллекции рейтингов.

```csharp
public void AssignRanks(IEnumerable<AssetRating> ratings)
```

**Логика:**
- Ранжировать по количеству транзакций (Buy + Sell)
- Ранжировать по объёму транзакций (TotalBuyAmount + TotalSellAmount)
- При равенстве использовать StockCardId для детерминированности

#### 3. CalculateIncrementalUpdate

Обновляет рейтинг при поступлении новой транзакции (оптимизация для event-driven).

```csharp
public AssetRating CalculateIncrementalUpdate(
    AssetRating existingRating,
    AssetTransaction newTransaction)
```

**Логика:**
- Клонировать существующий рейтинг
- Обновить счётчики и суммы на основе новой транзакции
- Пометить как обновлённый

## Критерии приёмки

- [ ] RatingCalculationService в Domain/Services/
- [ ] CreateRating() создаёт корректный AssetRating
- [ ] AssignRanks() присваивает правильные ранги (1, 2, 3, ...)
- [ ] Логика tie-breaking использует StockCardId
- [ ] CalculateIncrementalUpdate() корректно обновляет рейтинг
- [ ] Сервис stateless (без полей экземпляра)
- [ ] Валидация бизнес-правил с ArgumentException

## Структура файлов

```
Domain/
  Services/
    RatingCalculationService.cs
```
