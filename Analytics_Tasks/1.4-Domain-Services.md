# Task 1.4: Implement Domain Services

**Section:** Domain Layer  
**Priority:** High  
**Estimated Time:** 3-4 hours  
**Dependencies:** Tasks 1.1, 1.2, 1.3

## Objective

Implement RatingCalculationService containing core business logic for rating calculation and rank assignment.

## Context

Domain Services contain business logic that doesn't naturally fit in entities. RatingCalculationService orchestrates complex calculations across multiple AssetTransaction entities.

## Requirements

### RatingCalculationService

**Location:** `Domain/Services/RatingCalculationService.cs`

**Methods:**

#### 1. CreateRating

Creates AssetRating from a group of transactions.

```csharp
public AssetRating CreateRating(
    IGrouping<Guid, AssetTransaction> transactionGroup,
    Period period,
    AnalysisContext context,
    Guid? portfolioId)
{
    // Validate: if context == Portfolio, portfolioId must be set
    // Validate: if context == Global, portfolioId must be null
    
    var buyTransactions = transactionGroup
        .Where(t => t.TransactionType == TransactionType.Buy)
        .ToList();
    
    var sellTransactions = transactionGroup
        .Where(t => t.TransactionType == TransactionType.Sell)
        .ToList();
    
    // Calculate counts and amounts
    var buyCount = buyTransactions.Count;
    var sellCount = sellTransactions.Count;
    var totalBuyAmount = buyTransactions.Sum(t => t.TotalAmount);
    var totalSellAmount = sellTransactions.Sum(t => t.TotalAmount);
    
    // Create AssetRating entity
    return AssetRating.Create(
        stockCardId: transactionGroup.Key,
        periodStart: period.Start,
        periodEnd: period.End,
        context: context,
        portfolioId: portfolioId,
        buyCount: buyCount,
        sellCount: sellCount,
        buyAmount: totalBuyAmount,
        sellAmount: totalSellAmount
    );
}
```

#### 2. AssignRanks

Assigns ranking to a collection of AssetRatings.

```csharp
public void AssignRanks(IEnumerable<AssetRating> ratings)
{
    var ratingsList = ratings.ToList();
    
    // Rank by transaction count (Buy + Sell)
    var sortedByCount = ratingsList
        .OrderByDescending(r => r.BuyTransactionCount + r.SellTransactionCount)
        .ThenBy(r => r.StockCardId) // Tie-breaker for deterministic ranking
        .ToList();
    
    for (int i = 0; i < sortedByCount.Count; i++)
    {
        sortedByCount[i].AssignRanks(countRank: i + 1, amountRank: 0);
    }
    
    // Rank by transaction amount (Buy + Sell)
    var sortedByAmount = ratingsList
        .OrderByDescending(r => r.TotalBuyAmount + r.TotalSellAmount)
        .ThenBy(r => r.StockCardId) // Tie-breaker
        .ToList();
    
    for (int i = 0; i < sortedByAmount.Count; i++)
    {
        var rating = sortedByAmount[i];
        rating.AssignRanks(
            countRank: rating.TransactionCountRank, // Keep existing
            amountRank: i + 1
        );
    }
}
```

#### 3. CalculateIncrementalUpdate (Event-Driven Optimization)

Updates rating for specific asset after new transaction (optimization for event-driven aggregation).

```csharp
public AssetRating CalculateIncrementalUpdate(
    AssetRating existingRating,
    AssetTransaction newTransaction)
{
    // Clone existing rating
    var updated = existingRating.Clone();
    
    // Update counts and amounts based on new transaction
    if (newTransaction.TransactionType == TransactionType.Buy)
    {
        updated.UpdateCounts(
            buyCount: existingRating.BuyTransactionCount + 1,
            sellCount: existingRating.SellTransactionCount,
            buyAmount: existingRating.TotalBuyAmount + newTransaction.TotalAmount,
            sellAmount: existingRating.TotalSellAmount
        );
    }
    else
    {
        updated.UpdateCounts(
            buyCount: existingRating.BuyTransactionCount,
            sellCount: existingRating.SellTransactionCount + 1,
            buyAmount: existingRating.TotalBuyAmount,
            sellAmount: existingRating.TotalSellAmount + newTransaction.TotalAmount
        );
    }
    
    updated.MarkAsUpdated();
    return updated;
}
```

## Acceptance Criteria

- [x] `RatingCalculationService` class exists in `Domain/Services/`
- [x] `CreateRating()` method creates valid AssetRating from transactions
- [x] `AssignRanks()` assigns correct rankings (1, 2, 3, ...) based on count and amount
- [x] Tie-breaking logic uses StockCardId for deterministic ordering
- [x] `CalculateIncrementalUpdate()` correctly updates rating with new transaction
- [x] All business rule validations throw `ArgumentException` with clear messages
- [x] Service is stateless (no instance fields)

## File Structure

```
Domain/
  Services/
    RatingCalculationService.cs
```

## Testing

Create unit tests in Section 7 (Task 7.1) that verify:
- CreateRating with various transaction combinations
- AssignRanks with different sorting scenarios
- Tie-breaking logic
- CalculateIncrementalUpdate correctness
- Edge cases (empty transactions, single transaction, etc.)

## References

- Technical Specification: Section "Фоновые процессы" describes aggregation algorithm
- DDD: Domain Services contain logic that spans multiple entities